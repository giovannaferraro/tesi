#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdbool.h>
#include "CAM.h"  // This will be generated by asn1c compiler
#include <GenerationDeltaTime.h>
#include <ItsPduHeader.h>
#include <CoopAwareness.h>
#include <HighFrequencyContainer.h>
#include "asn_application.h"
#include "headermqtt.h"
#include "headersendcam.h"
#include <sys/time.h>


static size_t buf_offset;

typedef struct ritorno{
    asn_encode_to_new_buffer_result_t r;
    bool b;
} ritorno;

coord c;

#define MQTT_HOST "127.0.0.1"
#define MQTT_PORT 1883
#define MQTT_TOPIC "/haura/data"

int i = 0;

#ifdef MQTT_SUBSCRIPTION_H
#include <json-c/json.h>
void log_latency(float latency) {
    // Open file in append mode
    FILE *file = fopen("latency_data_7.txt", "a");
    
    // Check if the file opened successfully
    if (file == NULL) {
        perror("Error opening file");
        return;
    }

    // Write the float value to the file with 3 decimal precision
    fprintf(file, "%.3f\n", latency);

    // Close the file
    fclose(file);
}

// Callback function for when connected to the broker
void on_connect(struct mosquitto *mosq, void *obj, int rc) {
    if (rc == 0) {
        printf("Connected to broker\n");
        mosquitto_subscribe(mosq, NULL, MQTT_TOPIC, 0);
    } else {
        fprintf(stderr, "Connection failed: %d\n", rc);
    }
}

// Callback function for when a message is received
void on_message(struct mosquitto *mosq, void *obj, const struct mosquitto_message *message) {
    struct timeval tv;
    gettimeofday(&tv, NULL);

    // Parse JSON
    json_object *root = json_tokener_parse((char *)message->payload);
    if (!root) {
        fprintf(stderr, "JSON parsing failed\n");
        return;
    }

    json_object *data = json_object_object_get(root, "data");
    json_object *head = json_object_object_get(data, "head");
    json_object *stamp = json_object_object_get(head, "stamp");

    // Convert timestamp from JSON
    const char *stamp_str = json_object_get_string(stamp);
    char new_str[14]; 
    strncpy(new_str, stamp_str, 13);
    new_str[13] = '\0';
    long glass_time = strtol(new_str, NULL, 10);

    long current_time = tv.tv_sec * 1000 + tv.tv_usec / 1000;  // Current time in milliseconds

    printf("T1 - T0 = da frame a mqtts: %.6f\n", difftime(current_time, glass_time));
    log_latency(difftime(current_time, glass_time));
    i += 1;

    // Extract coordinates
    json_object *objects = json_object_object_get(data, "objects");
    if (json_object_array_length(objects) > 0) {
        json_object *first_obj = json_object_array_get_idx(objects, 0);
        json_object *lat_obj = json_object_object_get(first_obj, "latitude");
        json_object *lon_obj = json_object_object_get(first_obj, "longitude");

        c.lat = (int)(json_object_get_double(lat_obj) * 1000000 + 0.5);
        c.lon = (int)(json_object_get_double(lon_obj) * 1000000 + 0.5);
        printf("Latitude: %d\n", c.lat);
        printf("Longitude: %d\n", c.lon);
    }

    json_object_put(root);  // Free JSON object
    if (i==500){
        i=0;
        mosquitto_disconnect(mosq);
    }
    
}

//Start the MQTT client
coord start_mqtt() {
    mosquitto_lib_init();
    struct mosquitto *mosq = mosquitto_new(NULL, true, NULL);
    if (!mosq) {
        fprintf(stderr, "Mosquitto initialization failed\n");
        c.lat = 0;
        c.lon = 0;
        return c;
    }

    mosquitto_connect_callback_set(mosq, on_connect);
    mosquitto_message_callback_set(mosq, on_message);

    if (mosquitto_connect(mosq, MQTT_HOST, MQTT_PORT, 60) != MOSQ_ERR_SUCCESS) {
        fprintf(stderr, "MQTT connection failed\n");
        mosquitto_destroy(mosq);
        mosquitto_lib_cleanup();
        return c;
    }

    mosquitto_loop_forever(mosq, -1, 1);

    mosquitto_destroy(mosq);
    mosquitto_lib_cleanup();
    return c;
}

#else
#error "JSON_LIB_1 not defined!"
#endif

// Helper function to create and initialize a CAM message
CAM_t* create_cam_message(int lat, int lon) {
    CAM_t* cam = (CAM_t*)calloc(1, sizeof(CAM_t));
    if (!cam) return NULL;

    // Initialize header
    cam->header.protocolVersion = 2;
    cam->header.messageID = 2;  // CAM message ID
    cam->header.stationID = 10;

    // Initialize generation delta time (current time)
    cam->cam.generationDeltaTime = 10000;

    // Initialize basic container
    cam->cam.camParameters.basicContainer.stationType = 5;  // passengerCar
    
    // Set reference position
    cam->cam.camParameters.basicContainer.referencePosition.latitude = lat;
    cam->cam.camParameters.basicContainer.referencePosition.longitude = lon;
    cam->cam.camParameters.basicContainer.referencePosition.positionConfidenceEllipse.semiMajorConfidence = 282;
    cam->cam.camParameters.basicContainer.referencePosition.positionConfidenceEllipse.semiMinorConfidence = 280;
    cam->cam.camParameters.basicContainer.referencePosition.positionConfidenceEllipse.semiMajorOrientation = 1138;
    cam->cam.camParameters.basicContainer.referencePosition.altitude.altitudeValue = 6050;
    cam->cam.camParameters.basicContainer.referencePosition.altitude.altitudeConfidence = AltitudeConfidence_alt_020_00;

    // Initialize high frequency container
    cam->cam.camParameters.highFrequencyContainer.present = HighFrequencyContainer_PR_basicVehicleContainerHighFrequency;
    BasicVehicleContainerHighFrequency_t* highFreq = &cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency;

    // Set high-frequency parameters
    highFreq->heading.headingValue = 62;
    highFreq->heading.headingConfidence = 8;
    highFreq->speed.speedValue = 1163;
    highFreq->speed.speedConfidence = 4;
    highFreq->driveDirection = DriveDirection_forward;
    highFreq->vehicleLength.vehicleLengthValue = 42;
    highFreq->vehicleLength.vehicleLengthConfidenceIndication = VehicleLengthConfidenceIndication_trailerPresenceIsUnknown;
    highFreq->vehicleWidth = 18;
    highFreq->longitudinalAcceleration.longitudinalAccelerationValue = -2;
    highFreq->longitudinalAcceleration.longitudinalAccelerationConfidence = 102;
    highFreq->curvature.curvatureValue = 386;
    highFreq->curvature.curvatureConfidence = CurvatureConfidence_onePerMeter_0_01;
    highFreq->curvatureCalculationMode = CurvatureCalculationMode_yawRateUsed;
    highFreq->yawRate.yawRateValue = 2354;
    highFreq->yawRate.yawRateConfidence = YawRateConfidence_unavailable;

    // Set acceleration control
    uint8_t accelControl = 0x40;
    highFreq->accelerationControl = (AccelerationControl_t*)calloc(1, sizeof(AccelerationControl_t));
    highFreq->accelerationControl->buf = (uint8_t*)calloc(1, sizeof(uint8_t));
    highFreq->accelerationControl->buf[0] = accelControl;
    highFreq->accelerationControl->size = 1;
    highFreq->accelerationControl->bits_unused = 1;

    // Set steering wheel angle
    highFreq->steeringWheelAngle = (SteeringWheelAngle_t*)calloc(1, sizeof(SteeringWheelAngle_t));
    highFreq->steeringWheelAngle->steeringWheelAngleValue = 57;
    highFreq->steeringWheelAngle->steeringWheelAngleConfidence = 1;

    // Set lateral acceleration
    highFreq->lateralAcceleration = (LateralAcceleration_t*)calloc(1, sizeof(LateralAcceleration_t));
    highFreq->lateralAcceleration->lateralAccelerationValue = 43;
    highFreq->lateralAcceleration->lateralAccelerationConfidence = 102;
    
    return cam;
}

ritorno encode_cam_message(const CAM_t* cam) {
    asn_enc_rval_t er;
    ritorno ritorno;
    asn_encode_to_new_buffer_result_t res;
    
    
    int encoding = ATS_UNALIGNED_CANONICAL_PER;

    res = asn_encode_to_new_buffer(0, encoding, &asn_DEF_CAM, cam);
    if(res.result.encoded == -1){
        fprintf(stderr, "Could not encode Rectangle (at %s)\n",
        er.failed_type ? er.failed_type->name : "unknown");
        ritorno.r = res;
        ritorno.b = false;
    } else {
        if(res.buffer){
            char stringa_uper[res.result.encoded];
            for(size_t i=0; i<res.result.encoded; i++){
                //snprintf(&stringa_uper[i], res.result.encoded, "%02x", (char *)res.buffer);
                //printf("%02x", ((char *)res.buffer)[i]);
            }
        }
        ritorno.r = res;
        ritorno.b = true;
        }

    return ritorno;  
}

void bin_to_hex(const unsigned char *bin, size_t bin_len, char **hex_str) {
    *hex_str = malloc(bin_len * 2 + 1); // Allocate memory for hex string (2 chars per byte + 1 for null terminator)
    
    for (size_t i = 0; i < bin_len; i++) {
        sprintf(*hex_str + (i * 2), "%02x", bin[i]); // Convert each byte to 2 hex characters
    }
    (*hex_str)[bin_len * 2] = '\0'; // Null-terminate the string
}

void process_hex_string(const char *hex_str) {
    printf("Received hex string: %s\n", hex_str);
}

//QUESTO HEADER Ã¨ QUELLO FINALE DA USARE NEL FILE C++: int generate_uper_string(int lat, int lon) {
int main() {
    struct timeval time;

    gettimeofday(&time, NULL);
    long time_before_submqtt = time.tv_sec * 1000 + time.tv_usec / 1000;
    //getting mqtt info
    coord i = start_mqtt();
    gettimeofday(&time, NULL);
    long time_after_submqtt = time.tv_sec * 1000 + time.tv_usec / 1000;
    printf("Tempo passato per sottoscriversi a mqtt: %.2f\n", difftime(time_after_submqtt, time_before_submqtt));

    gettimeofday(&time, NULL);
    long time_before_createcam = time.tv_sec * 1000 + time.tv_usec / 1000;
    //generating CAM asn
    CAM_t* cam = create_cam_message(i.lat, i.lon);
    //gettimeofday(&time, NULL);
    //long time_after_createcam = time.tv_sec * 1000 + time.tv_usec / 1000;
    //printf("Tempo passato per creare un cam asn: %.2f\n", difftime(time_after_createcam, time_before_createcam));


    if (!cam) {
        fprintf(stderr, "Failed to create CAM message\n");
        return 1;
    }
    
    asn_encode_to_new_buffer_result_t res = encode_cam_message(cam).r;
    char *hex_string = NULL;
    bin_to_hex(res.buffer, res.result.encoded, &hex_string);
    gettimeofday(&time, NULL);
    long afterencode = time.tv_sec * 1000 + time.tv_usec / 1000;

    printf("Tempo passato per fare encoding del cam: %.2f\n", difftime(afterencode, time_before_createcam));
    //printf("Tempo totale: %.2f\n\n\n", difftime(afterencode, time_before_submqtt));


    int ret = send_cam(hex_string);
    gettimeofday(&time, NULL);
    long aftersend = time.tv_sec * 1000 + time.tv_usec / 1000;
    printf("Tempo per create uper cam e json: %.2f\n", difftime(aftersend, time_before_createcam));
    

    free(hex_string); 

    ASN_STRUCT_FREE(asn_DEF_CAM, cam);

    return 0;
}