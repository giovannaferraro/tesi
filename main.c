#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdbool.h>
#include "CAM.h"  // This will be generated by asn1c compiler
#include <GenerationDeltaTime.h>
#include <ItsPduHeader.h>
#include <CoopAwareness.h>
#include <HighFrequencyContainer.h>
#include "asn_application.h"
#include "headermqtt.h"
#include "headersendcam.h"

 
//static unsigned char buf[4096];
// unaligned basic per = 8
// unaligned canonical per = 9
// canonical xer = 11


static size_t buf_offset;

typedef struct ritorno{
    asn_encode_to_new_buffer_result_t r;
    bool b;
} ritorno;

// Helper function to create and initialize a CAM message
CAM_t* create_cam_message(int lat, int lon) {
    CAM_t* cam = (CAM_t*)calloc(1, sizeof(CAM_t));
    if (!cam) return NULL;

    // Initialize header
    cam->header.protocolVersion = 2;
    cam->header.messageID = 2;  // CAM message ID
    cam->header.stationID = 10;

    // Initialize generation delta time (current time)
    cam->cam.generationDeltaTime = 10000;

    // Initialize basic container
    cam->cam.camParameters.basicContainer.stationType = 5;  // passengerCar
    
    // Set reference position
    cam->cam.camParameters.basicContainer.referencePosition.latitude = lat;
    cam->cam.camParameters.basicContainer.referencePosition.longitude = lon;
    cam->cam.camParameters.basicContainer.referencePosition.positionConfidenceEllipse.semiMajorConfidence = 282;
    cam->cam.camParameters.basicContainer.referencePosition.positionConfidenceEllipse.semiMinorConfidence = 280;
    cam->cam.camParameters.basicContainer.referencePosition.positionConfidenceEllipse.semiMajorOrientation = 1138;
    cam->cam.camParameters.basicContainer.referencePosition.altitude.altitudeValue = 6050;
    cam->cam.camParameters.basicContainer.referencePosition.altitude.altitudeConfidence = AltitudeConfidence_alt_020_00;

    // Initialize high frequency container
    cam->cam.camParameters.highFrequencyContainer.present = HighFrequencyContainer_PR_basicVehicleContainerHighFrequency;
    //auto& highFreq = cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency;

    // Set heading
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.heading.headingValue = 62;
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.heading.headingConfidence = 8;

    // Set speed
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.speed.speedValue = 1163;
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.speed.speedConfidence = 4;

    // Set drive direction
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.driveDirection = DriveDirection_forward;

    // Set vehicle dimensions
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.vehicleLength.vehicleLengthValue = 42;
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.vehicleLength.vehicleLengthConfidenceIndication = VehicleLengthConfidenceIndication_trailerPresenceIsUnknown;
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.vehicleWidth = 18;

    // Set acceleration values
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.longitudinalAcceleration.longitudinalAccelerationValue = -2;
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.longitudinalAcceleration.longitudinalAccelerationConfidence = 102;

    // Set curvature
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.curvature.curvatureValue = 386;
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.curvature.curvatureConfidence = CurvatureConfidence_onePerMeter_0_01;
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.curvatureCalculationMode = CurvatureCalculationMode_yawRateUsed;

    // Set yaw rate
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.yawRate.yawRateValue = 2354;
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.yawRate.yawRateConfidence = YawRateConfidence_unavailable;

    // Set acceleration control (as a bit string)
    uint8_t accelControl = 0x40;  // Binary: 01000000
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.accelerationControl = (AccelerationControl_t*)calloc(1, sizeof(AccelerationControl_t));
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.accelerationControl->buf = (uint8_t*)calloc(1, sizeof(uint8_t));
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.accelerationControl->buf[0] = accelControl;
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.accelerationControl->size = 1;
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.accelerationControl->bits_unused = 1;

    // Set steering wheel angle
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.steeringWheelAngle = (SteeringWheelAngle_t*)calloc(1, sizeof(SteeringWheelAngle_t));
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.steeringWheelAngle->steeringWheelAngleValue = 57;
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.steeringWheelAngle->steeringWheelAngleConfidence = 1;

    // Set lateral acceleration
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.lateralAcceleration = (LateralAcceleration_t*)calloc(1, sizeof(LateralAcceleration_t));
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.lateralAcceleration->lateralAccelerationValue = 43;
    cam->cam.camParameters.highFrequencyContainer.choice.basicVehicleContainerHighFrequency.lateralAcceleration->lateralAccelerationConfidence = 102;
    return cam;
}

ritorno encode_cam_message(const CAM_t* cam) {
    asn_enc_rval_t er;
    ritorno ritorno;
    asn_encode_to_new_buffer_result_t res;
    
    
    int encoding = ATS_UNALIGNED_CANONICAL_PER;

    res = asn_encode_to_new_buffer(0, encoding, &asn_DEF_CAM, cam);
    if(res.result.encoded == -1){
        fprintf(stderr, "Could not encode Rectangle (at %s)\n",
        er.failed_type ? er.failed_type->name : "unknown");
        ritorno.r = res;
        ritorno.b = false;
    } else {
        if(res.buffer){
            char stringa_uper[res.result.encoded];
            for(size_t i=0; i<res.result.encoded; i++){
                //snprintf(&stringa_uper[i], res.result.encoded, "%02x", (char *)res.buffer);
                printf("%02x", ((char *)res.buffer)[i]);
            }

        printf("tutta stringa %s ", stringa_uper);
        }
        ritorno.r = res;
        ritorno.b = true;
        }

    return ritorno;  
}


void bin_to_hex(const unsigned char *bin, size_t bin_len, char **hex_str) {
    *hex_str = malloc(bin_len * 2 + 1); // Allocate memory for hex string (2 chars per byte + 1 for null terminator)
    
    for (size_t i = 0; i < bin_len; i++) {
        sprintf(*hex_str + (i * 2), "%02x", bin[i]); // Convert each byte to 2 hex characters
    }
    (*hex_str)[bin_len * 2] = '\0'; // Null-terminate the string
}

void process_hex_string(const char *hex_str) {
    printf("Received hex string: %s\n", hex_str);
}



//QUESTO HEADER Ã¨ QUELLO FINALE DA USARE NEL FILE C++: int generate_uper_string(int lat, int lon) {
int main() {

    coord i = start_mqtt();

    CAM_t* cam = create_cam_message(i.lat, i.lon);

    if (!cam) {
        fprintf(stderr, "Failed to create CAM message\n");
        return 1;
    }
    
    ritorno retval = encode_cam_message(cam);

    asn_encode_to_new_buffer_result_t res = retval.r;
    
    char *hex_string = NULL;
    bin_to_hex(res.buffer, res.result.encoded, &hex_string);
    process_hex_string(hex_string); 

    int ret = send_cam(hex_string);

    free(hex_string); 


    //printf("retval vale %d: ", retval.b);
    //printf("%d", retval.r);

    ASN_STRUCT_FREE(asn_DEF_CAM, cam);
    return 0;
}